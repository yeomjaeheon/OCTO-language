# OCTO-language

### 목적
백준에서 아직 [Brainfuck](https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%A0%88%EC%9D%B8%ED%8D%BD)으로 풀리지 않은 문제들을 풀고 싶었으나 폰 노이만이 아니라 한낱 인간에 불과한 나에게는 불가능한 작업이었기에 시작한 프로젝트이다(생기부에 적으려는 이유도 있다). 최종적인 목표는 고수준의 언어를 Brainfuck으로 번역해주는 트랜스파일러를 만드는 것인데, 언어 해석기를 밑바닥부터 만들어보기로 한 김에 언어까지 새로 설계해 보기로 하였다. 새로 설계한 언어는 문법은 파이썬에서 영향을 많이 받았으며 패러다임은 최근 관심이 생긴 함수형 프로그래밍으로 정해 반복문 자체를 없애보기로 하였다. 가능한 적은 키워드가 사용되도록 하는 것 또한 목표 중 하나이다. Brainfuck이 8개의 명령어만을 사용하기 때문에 이름을 [OCTO](https://en.dict.naver.com/#/entry/enko/f7b2f4a779224d6a9d6b8aa889b1f496)로 정했다.

### 문법
OCTO의 프로그래밍 패러다임은 함수형 프로그래밍으로, 이렇게 언어를 설계한 것에는 순전히 미학적인 관점에서의 이유와 구현상의 편의성과 관련된 이유를 통틀어 몇 가지 이유가 있다.

---
1. 함수형 프로그래밍 패러다임에서 모든 변수는 선언 이후 값을 바꿀 수 없으므로 사실상 상수함수와 다를바가 없어 Brainfuck 레벨에서의 처리과정에 이점이 있다.

2. 함수형 프로그래밍 패러다임의 특성상 처리 순서에 조금 덜 신경을 써도 된다(입력 받는 경우를 제외하면 선언 이후 변하지 않아 전처리가 용이하다).

3. 꼬리재귀 등의 방법을 이용해 반복문을 대체하여 반복문과 반복문(for, while 등)에 관련된 키워드들(예를 들어 continue와 break)을 없앰으로써 키워드 개수를 더 줄일 수 있다.
---

```
//입력받은 수까지 소수의 합 구하기

func prime(int n, int a):
    if a > 1:
        if n % a == 0:
            return 0
        else:
            return prime(n, a - 1)
    else:
        return 1

func is_prime(int n):
    if n > 1:
        return prime(n, n - 1)
    else:
        return 0

func repet(int n, int s):
    if n > 0:
        if is_prime(n):
            return repet(n - 1, s + n)
        return repet(n - 1, s)
    else:
        return s

func main():
    int n = int(gets()) //입력받은 문자열을 정수형으로 변환해 저장
    int sum = repet(n, 0)
    puts(sum) //출력
```

위의 코드는 [1, n]에서의 모든 소수의 합을 구해 출력하는 코드를 OCTO로 작성한 것이다. 이 코드를 이용해 OCTO의 문법을 설명하도록 하겠다.

`//`를 이용해 한 줄을, `/*`와 `*/`를 이용해 여러 줄을 주석 처리 할 수 있다.

모든 함수는 위와 같이 `func` 키워드를 사용해 정의된다(물론 변수를 상수함수로 본다면 아니기는 하다).

모든 프로그램은 `main` 함수를 가지고 있어야 하며 모든 프로그램은 `main` 함수에서부터 시작된다.

불리언 자료형의 경우 따로 존재하지는 않으나 0은 False로, 0이 아닌 수는 True로 인식된다.

코드에서 볼 수 있듯이 꼬리재귀를 활용해 재귀호출시 스택 오버플로우가 일어나는 것을 막았으며, OCTO에서는 일반적인 재귀호출도 지원은 하지만 꼬리재귀가 권장된다.
